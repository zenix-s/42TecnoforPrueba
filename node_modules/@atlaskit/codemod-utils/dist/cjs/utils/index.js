"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceImportStatementFor = exports.renameNamedImportWithAliasName = exports.flattenCertainChildPropsAsProp = exports.elevateComponentToNewEntryPoint = exports.createTransformer = exports.createRenameJSXFunc = exports.createRenameImportFor = exports.createRenameFuncFor = exports.createRemoveFuncFor = exports.createRemoveFuncAddCommentFor = exports.createConvertFuncFor = exports.changeImportEntryPoint = void 0;
var _support = require("./support");
const createRemoveFuncFor = (component, importName, prop, predicate = () => true, comment) => (j, source) => {
  const specifier = (0, _support.getNamedSpecifier)(j, source, component, importName);
  if (!specifier) {
    return;
  }
  source.findJSXElements(specifier).forEach(element => {
    if (predicate(j, element) && comment) {
      (0, _support.addCommentToStartOfFile)({
        j,
        base: source,
        message: comment
      });
    } else {
      (0, _support.getJSXAttributesByName)(j, element, prop).forEach(attribute => {
        j(attribute).remove();
      });
    }
  });
};
exports.createRemoveFuncFor = createRemoveFuncFor;
const createRenameFuncFor = (component, from, to) => (j, source) => {
  const defaultSpecifier = (0, _support.getDefaultSpecifier)(j, source, component);
  if (!defaultSpecifier) {
    return;
  }
  source.findJSXElements(defaultSpecifier).forEach(element => {
    (0, _support.getJSXAttributesByName)(j, element, from).forEach(attribute => {
      j(attribute).replaceWith(j.jsxAttribute(j.jsxIdentifier(to), attribute.node.value));
    });
  });
};
exports.createRenameFuncFor = createRenameFuncFor;
const createConvertFuncFor = (component, from, to, predicate) => (j, source) => {
  const defaultSpecifier = (0, _support.getDefaultSpecifier)(j, source, component);
  if (!defaultSpecifier) {
    return;
  }
  source.findJSXElements(defaultSpecifier).forEach(element => {
    (0, _support.getJSXAttributesByName)(j, element, from).forEach(attribute => {
      const shouldConvert = predicate && predicate(attribute.node.value) || false;
      const node = j.jsxAttribute(j.jsxIdentifier(to));
      if (shouldConvert) {
        j(attribute).insertBefore(node);
      }
    });
  });
};
exports.createConvertFuncFor = createConvertFuncFor;
const replaceImportStatementFor = (pkg, convertMap) => (j, root) => {
  root.find(j.ImportDeclaration).filter(path => path.node.source.value === pkg).forEach(path => {
    const defaultSpecifier = (path.value.specifiers || []).filter(specifier => specifier.type === 'ImportDefaultSpecifier');
    const defaultDeclarations = defaultSpecifier.map(s => {
      return j.importDeclaration([s], j.literal(convertMap['default']));
    });
    const otherSpecifier = (path.value.specifiers || []).filter(specifier => specifier.type === 'ImportSpecifier');
    j(path).replaceWith(defaultDeclarations);
    const otherDeclarations = otherSpecifier.map(s => {
      const localName = s.local.name;
      if (convertMap[localName]) {
        return j.importDeclaration([j.importDefaultSpecifier(j.identifier(localName))], j.literal(convertMap[localName]));
      } else {
        return j.importDeclaration([j.importDefaultSpecifier(j.identifier(localName))], j.literal(convertMap['*']));
      }
    });
    j(path).insertAfter(otherDeclarations);
  });
};
exports.replaceImportStatementFor = replaceImportStatementFor;
const createRenameImportFor = (component, from, to) => (j, source) => {
  source.find(j.ImportDeclaration).filter(path => path.node.source.value === component).forEach(path => {
    j(path).replaceWith(j.importDeclaration(path.value.specifiers, j.literal(to)));
  });
};
exports.createRenameImportFor = createRenameImportFor;
const createTransformer = (migrates, shouldApplyTransform) => (fileInfo, {
  jscodeshift: j
}, options) => {
  const source = j(fileInfo.source);

  // If shouldApplyTransform not provided then perform old behaviour
  if (!shouldApplyTransform || shouldApplyTransform(j, source)) {
    migrates.forEach(tf => tf(j, source));
    return source.toSource(options.printOptions);
  }
  return fileInfo.source;
};
exports.createTransformer = createTransformer;
const elevateComponentToNewEntryPoint = (pkg, toPkg, innerElementName) => (j, root) => {
  const importDeclarations = root.find(j.ImportDeclaration).filter(path => path.node.source.value === pkg);
  const defaultSpecifier = importDeclarations.find(j.ImportDefaultSpecifier).nodes();
  const otherSpecifier = importDeclarations.find(j.ImportSpecifier).nodes();
  const newDefaultSpecifier = defaultSpecifier.map(s => {
    return j.importDeclaration([j.importDefaultSpecifier(s.local)], j.literal(pkg));
  });
  const newOtherSpecifiers = otherSpecifier.map(s => {
    if (s.imported.name === innerElementName) {
      return j.importDeclaration([j.importDefaultSpecifier(s.local)], j.literal(toPkg));
    } else {
      return j.importDeclaration([s], j.literal(pkg));
    }
  });
  importDeclarations.forEach(path => {
    j(path).replaceWith(newDefaultSpecifier);
    j(path).insertBefore(newOtherSpecifiers);
  });
};
exports.elevateComponentToNewEntryPoint = elevateComponentToNewEntryPoint;
const flattenCertainChildPropsAsProp = (component, propName, childProps) => (j, source) => {
  const defaultSpecifier = (0, _support.getDefaultSpecifier)(j, source, component);
  if (!defaultSpecifier) {
    return;
  }
  source.findJSXElements(defaultSpecifier).forEach(element => {
    (0, _support.getJSXAttributesByName)(j, element, propName).forEach(attribute => {
      j(attribute).find(j.JSXExpressionContainer).find(j.ObjectExpression).forEach(objectExpression => {
        objectExpression.node.properties.forEach(property => {
          childProps.forEach(childProp => {
            if ((property.type === 'Property' || property.type === 'ObjectProperty') && property.key.type === 'Identifier' && property.key.name === childProp) {
              var _element$node$opening;
              (_element$node$opening = element.node.openingElement.attributes) === null || _element$node$opening === void 0 ? void 0 : _element$node$opening.push(j.jsxAttribute(j.jsxIdentifier(childProp), j.jsxExpressionContainer(property.value)));
            }
          });
        });
      });
    });
  });
};
exports.flattenCertainChildPropsAsProp = flattenCertainChildPropsAsProp;
const createRenameJSXFunc = (packagePath, from, to, fallback = undefined) => (j, source) => {
  const namedSpecifier = (0, _support.getNamedSpecifier)(j, source, packagePath, from);
  const toName = fallback ? (0, _support.getSafeImportName)({
    j,
    base: source,
    currentDefaultSpecifierName: namedSpecifier,
    desiredName: to,
    fallbackName: fallback
  }) : to;
  const existingAlias = source.find(j.ImportDeclaration).filter(path => path.node.source.value === packagePath).find(j.ImportSpecifier).nodes().map(specifier => {
    if (from !== specifier.imported.name) {
      return null;
    }
    // If aliased: return the alias
    if (specifier.local && from !== specifier.local.name) {
      return specifier.local.name;
    }
    return null;
  }).filter(Boolean)[0] || null;
  source.find(j.ImportDeclaration).filter(path => path.node.source.value === packagePath).find(j.ImportSpecifier).filter(importSpecifier => {
    const identifier = j(importSpecifier).find(j.Identifier).get();
    if (from === identifier.value.name || existingAlias === identifier.value.name) {
      return true;
    }
    return false;
  }).replaceWith([j.importSpecifier(j.identifier(toName), existingAlias ? j.identifier(existingAlias) : null)], j.literal(packagePath));
};
exports.createRenameJSXFunc = createRenameJSXFunc;
const createRemoveFuncAddCommentFor = (component, prop, comment) => (j, source) => {
  const defaultSpecifier = (0, _support.getDefaultSpecifier)(j, source, component);
  if (!defaultSpecifier) {
    return;
  }
  source.findJSXElements(defaultSpecifier).forEach(element => {
    (0, _support.getJSXAttributesByName)(j, element, prop).forEach(attribute => {
      j(attribute).remove();
      if (comment) {
        (0, _support.addCommentToStartOfFile)({
          j,
          base: source,
          message: comment
        });
      }
    });
  });
};
exports.createRemoveFuncAddCommentFor = createRemoveFuncAddCommentFor;
const renameNamedImportWithAliasName = (component, from, to) => (j, source) => {
  source.find(j.ImportDeclaration).filter(path => path.node.source.value === component).find(j.ImportSpecifier).filter(path => path.node.imported.name === from).forEach(path => {
    const localName = path.node.local.name;
    j(path).replaceWith(j.importSpecifier(j.identifier(to), j.identifier(localName)));
  });
};
exports.renameNamedImportWithAliasName = renameNamedImportWithAliasName;
const changeImportEntryPoint = (oldPackageName, importToConvert, newPackageName, shouldBeTypeImport) => (j, root) => {
  root.find(j.ImportDeclaration, {
    source: {
      value: oldPackageName
    }
  }).forEach(path => {
    var _currentImportSpecifi;
    const currentImportSpecifier = (path.value.specifiers || []).find(specifier => {
      if (specifier.type === 'ImportSpecifier') {
        return specifier.imported.name === importToConvert;
      }
      return false;
    });
    if (!currentImportSpecifier) {
      return;
    }
    const importedSpecifierName = currentImportSpecifier.imported.name;
    const localSpecifierName = (_currentImportSpecifi = currentImportSpecifier.local) === null || _currentImportSpecifi === void 0 ? void 0 : _currentImportSpecifi.name;
    const newIdentifier = j.importSpecifier(j.identifier(importedSpecifierName), localSpecifierName ? j.identifier(localSpecifierName) : undefined);

    // check if new import exists, if not create it
    (0, _support.tryCreateImport)(j, root, oldPackageName, newPackageName, shouldBeTypeImport);

    // remove the old import specifier, but NOT the whole package
    root.find(j.ImportDeclaration, {
      source: {
        value: oldPackageName
      }
    }).find(j.ImportSpecifier).filter(path => path.value.imported.name === importToConvert).remove();

    // adds import specifier to new import
    (0, _support.addToImport)(j, root, newIdentifier, newPackageName);

    // if there are any imports with no specifiers, remove the whole import
    root.find(j.ImportDeclaration, {
      source: {
        value: oldPackageName
      }
    }).filter(path => {
      var _path$value$specifier;
      return !((_path$value$specifier = path.value.specifiers) !== null && _path$value$specifier !== void 0 && _path$value$specifier.length);
    }).remove();
  });
};
exports.changeImportEntryPoint = changeImportEntryPoint;